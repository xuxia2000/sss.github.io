<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>文件上传下载总结</title>
    <link href="/2021/06/20/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E6%80%BB%E7%BB%93/"/>
    <url>/2021/06/20/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>这是关于文件上传下载总结的博客</p><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><h3 id="前端代码"><a href="#前端代码" class="headerlink" title="前端代码"></a>前端代码</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;form action=&quot;/load&quot; <span class="hljs-keyword">method</span>=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;<br>        &lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=&quot;file&quot; <span class="hljs-type">name</span>=&quot;MyFile&quot;&gt;<br>        &lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=&quot;submit&quot; <span class="hljs-keyword">value</span>=&quot;上传文件&quot;&gt;<br>    &lt;/form&gt;<br></code></pre></td></tr></table></figure><h3 id="servlet-实现"><a href="#servlet-实现" class="headerlink" title="servlet 实现"></a>servlet 实现</h3><p>servlet文件上传中最重要的类 part </p><p>part的获取</p><blockquote><p>Part part = request.getPart(“MyFile”);</p></blockquote><p>part类获取文件名</p><blockquote><p>String filename = part.getSubmittedFileName();</p></blockquote><p>part类获取输入流</p><blockquote><p>InputStream is = part.getInputStream();</p></blockquote><p>获取文件存放路径</p><blockquote><p>String realPath = request.getServletContext().getRealPath(“/“);<br>File file = new File(realPath+filename);<br>也可以自己决定存放路径<br>File file = new File(“F:\myblogssm\“ + filename);</p></blockquote><p>获取输出流</p><blockquote><p>FileOutputStream fos = new FileOutputStream(file);</p></blockquote><p>通过输出流写入服务器文件系统</p><blockquote><p> byte[] bytes = new byte[1024];<br>        int length = 0;<br>        while ((length = is.read(bytes))!= -1){<br>            fos.write(bytes,0,length);<br>        }</p></blockquote><blockquote><p>part转存文件<br>part.write() // 参数是string,直接放存入的路径</p></blockquote><h3 id="springboot实现"><a href="#springboot实现" class="headerlink" title="springboot实现"></a>springboot实现</h3><p>其中最重要的类 MultipartFile<br>获取MultipartFile类</p><blockquote><p>直接通过参数传递<br> public String onfile(MultipartFile MyFile) throws IOException </p></blockquote><p>MultipartFile获取文件名</p><blockquote><p>String filename = MyFile.getOriginalFilename()</p></blockquote><p>MultipartFile获取输入流</p><blockquote><p>InputStream inputStream = MyFile.getInputStream();</p></blockquote><p>获取文件存放路径</p><blockquote><p>直接自己设置<br>File file1 = new File(“F:\myblogssm\“ + MyFile.getOriginalFilename());</p></blockquote><p>获取输出流</p><blockquote><p>FileOutputStream fos = new FileOutputStream(file1);</p></blockquote><p>写入文件系统</p><blockquote><p>byte[] bytes = new byte[1024];<br>int length = 0;<br>while ((length = is.read(bytes))!= -1){<br>fos.write(bytes,0,length);<br>}</p></blockquote><blockquote><p>直接转存文件<br>MyFile.transferTo(file1); //可以接收文件类，也可以接收路径字符串</p></blockquote><p>springboot简单完整代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">public <span class="hljs-built_in">String</span> onfile(MultipartFile MyFile) throws IOException &#123;<br>       File file1 = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;F:\\myblogssm\\&quot;</span> + MyFile.getOriginalFilename());<br>       <span class="hljs-keyword">if</span> (!file1.exists())&#123;<br>           file1.createNewFile();<br>       &#125;<br>       MyFile.transferTo(file1);<br>       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h2><h3 id="前端代码-1"><a href="#前端代码-1" class="headerlink" title="前端代码"></a>前端代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;body&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>文件下载<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>    个人照片&lt;a href=<span class="hljs-string">&quot;/download/1.png&quot;</span>&gt;个人照片&lt;/a&gt;<br>    个人简历&lt;a href=<span class="hljs-string">&quot;/upload/个人简历.pdf&quot;</span>&gt;个人照片&lt;/a&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><h3 id="servlet实现"><a href="#servlet实现" class="headerlink" title="servlet实现"></a>servlet实现</h3><p>获取文件名，该参数由前端传递而来</p><blockquote><p>String file = request.getParameter(“file”);</p></blockquote><p>获取文件存储路径</p><blockquote><p>String path = request.getServletContext().getRealPath(“”)+”/“+file; //默认认为文件在当前项目的根目录</p></blockquote><p>根据路径获取输入流（先将文件输入到内存）</p><blockquote><p> FileInputStream fis = new FileInputStream(path);</p></blockquote><p>设置请求头信息</p><blockquote><p>response.setCharacterEncoding(“utf-8”);<br>response.setHeader(“Content-Disposition”, “attachment; filename=”+file);</p></blockquote><p>获取输出流</p><blockquote><p> ServletOutputStream out = response.getOutputStream();</p></blockquote><p>将内存里的文件通过输出流返回</p><blockquote><p>byte[] bt = new byte[1024];<br>        int length = 0;<br>        while((length=fis.read(bt))!=-1){<br>            out.write(bt,0,length);<br>        }<br>        out.close();<br>    }</p></blockquote><h3 id="springboot实现-1"><a href="#springboot实现-1" class="headerlink" title="springboot实现"></a>springboot实现</h3><p>获取文件名（通过@PathVariable可实现restful风格）</p><blockquote><p> @GetMapping(“download/{filename}”)<br>    public ResponseEntity&lt;byte[]&gt; download(@PathVariable String filename) throws IOException {</p></blockquote><p>获取文件的存储路径</p><blockquote><p>String filepath= “F:\myblogssm\“+filename;（根据自己上传路径写）</p></blockquote><p>根据路径获取输入流（先将文件输入到内存）</p><blockquote><p> File file =new File(filepath);<br>        //创建字节输入流，这里不使用Buffer类<br>        InputStream in = new FileInputStream(file);</p></blockquote><p>将服务器存储的文件读入到内存</p><blockquote><p>//available:获取输入流所读取的文件的最大字节数<br>byte[] body = new byte[in.available()];<br>        //把字节读取到数组中<br>        in.read(body);</p></blockquote><p>设置请求头</p><blockquote><p>MultiValueMap&lt;String, String&gt; headers = new HttpHeaders();<br>        headers.add(“Content-Disposition”, “attchement;filename=” + file.getName());<br>        //设置响应状态<br>        HttpStatus statusCode = HttpStatus.OK;</p></blockquote><p>将存储了信息的数组封装到ResponseEntity类中</p><blockquote><p>ResponseEntity&lt;byte[]&gt; entity = new ResponseEntity&lt;byte[]&gt;(body, headers, statusCode);<br>        return entity;//返回</p></blockquote><h2 id="springboot完整下载代码"><a href="#springboot完整下载代码" class="headerlink" title="springboot完整下载代码"></a>springboot完整下载代码</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs arduino">@<span class="hljs-built_in">GetMapping</span>(<span class="hljs-string">&quot;download/&#123;filename&#125;&quot;</span>)<br>   <span class="hljs-keyword">public</span> ResponseEntity&lt;<span class="hljs-keyword">byte</span>[]&gt;<span class="hljs-built_in">download</span>(@PathVariable <span class="hljs-keyword">String</span> filename) throws IOException &#123;<br>       <span class="hljs-comment">//下载文件的路径(这里绝对路径)</span><br>       <span class="hljs-keyword">String</span> filepath= <span class="hljs-string">&quot;F:\\myblogssm\\&quot;</span>+filename;<br>       <span class="hljs-built_in">File</span> file =<span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-built_in">File</span></span>(filepath);<br>       <span class="hljs-comment">//创建字节输入流，这里不实用Buffer类</span><br>       InputStream in = <span class="hljs-keyword">new</span> <span class="hljs-built_in">FileInputStream</span>(file);<br>       <span class="hljs-comment">//available:获取输入流所读取的文件的最大字节数</span><br>       <span class="hljs-keyword">byte</span>[] body = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[in.<span class="hljs-built_in">available</span>()];<br>       <span class="hljs-comment">//把字节读取到数组中</span><br>       in.<span class="hljs-built_in">read</span>(body);<br>       <span class="hljs-comment">//设置请求头</span><br>       MultiValueMap&lt;<span class="hljs-keyword">String</span>, <span class="hljs-keyword">String</span>&gt; headers = <span class="hljs-keyword">new</span> <span class="hljs-built_in">HttpHeaders</span>();<br>       headers.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;Content-Disposition&quot;</span>, <span class="hljs-string">&quot;attchement;filename=&quot;</span> + file.<span class="hljs-built_in">getName</span>());<br>       <span class="hljs-comment">//设置响应状态</span><br>       HttpStatus statusCode = HttpStatus.OK;<br>       in.<span class="hljs-built_in">close</span>();<br>       ResponseEntity&lt;<span class="hljs-keyword">byte</span>[]&gt; entity = <span class="hljs-keyword">new</span> ResponseEntity&lt;<span class="hljs-keyword">byte</span>[]&gt;(body, headers, statusCode);<br>       <span class="hljs-keyword">return</span> entity;<span class="hljs-comment">//返回</span><br>   &#125;<br><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><pre><code>上传时通过 par t或 MultipartFile 类获取输入流，通过文件路径获取输出流，将输入流中的信息通过输出流写入文件系统，下载时通过文件路径获取输入流，通过response.getOutputStream 然后将信息全部写入输出流中，springboot是直接封装了输入流存储信息的字节数组。除此之外，要记得设置请求头的状态</code></pre>]]></content>
    
    
    <categories>
      
      <category>springboot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springboot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见的问题</title>
    <link href="/2021/06/20/%E5%B8%B8%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2021/06/20/%E5%B8%B8%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>Http协议和Servlet，request、response、cookie、session<br>跨域请求，sso单点登录，上传下载文件，负载均衡<br>分布式缓存<br>分布式文件系统/CDN<br>分布式RPC<br>分布式数据库/Nosql<br>分布式消息中间件<br>分布式session问题</p><h2 id="端口被占用"><a href="#端口被占用" class="headerlink" title="端口被占用"></a>端口被占用</h2><ol><li>netstat -aon|findstr 8080</li><li>taskkill /f /t /im 进程号</li></ol>]]></content>
    
    
    <categories>
      
      <category>javaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaWeb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springboot之上传下载</title>
    <link href="/2021/06/20/springboot%E4%B9%8B%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/"/>
    <url>/2021/06/20/springboot%E4%B9%8B%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<p>这是关于springboot上传与下载的博客<br><a href="https://zhuanlan.zhihu.com/p/165383016">博客参考</a><br><a href="https://blog.csdn.net/a3226988/article/details/82685094">servlet的文件上传与下载</a></p><h2 id="前端代码"><a href="#前端代码" class="headerlink" title="前端代码"></a>前端代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;form action=<span class="hljs-string">&quot;upload&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span> enctype=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;<br>       <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;MyFile&quot;</span>&gt;</span></span><br><span class="xml">       <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;上传文件&quot;</span>&gt;</span></span><br><span class="xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>action=”onfile”是指请求会发到这个路径，controller需要处理，<br>enctype=’multipart/form-data’，必须要加</p><blockquote><p>   application/x-www-form-urlencoded：默认编码方式，在发送前编码所有字符（默认）使用url编码方式，和get请求有些相似。但这种方式如果发送大量二进制数据效率会比较低。multipart/form-data:不对字符编码。在使用包含文件上传控件的表单时，必须使用该值。通常用来向服务端发送二进制数据，而我们的文件也主要以二进制的方式进行传输。text/plain：空格转换为 “+” 加号，但不对特殊字符编码。</p></blockquote><h3 id="前端需要注意的事情"><a href="#前端需要注意的事情" class="headerlink" title="前端需要注意的事情"></a>前端需要注意的事情</h3><blockquote><p>  表单的enctype要为multipart/form-data类型，表示二进制传输。在一个form表单内定义一个input为file属性的标签，代表文件上传。form表单的method需要为post。enctype要为multipart/form-data类型，表示二进制传输。</p></blockquote><h3 id="控制器代码"><a href="#控制器代码" class="headerlink" title="控制器代码"></a>控制器代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">@PostMapping(<span class="hljs-string">&quot;onfile&quot;</span>)<br> @ResponseBody<br> public <span class="hljs-built_in">String</span> onfile(MultipartFile file) throws IOException &#123;<br>     File file1 =<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;F:/fileupload/&quot;</span>+file.getOriginalFilename());<span class="hljs-comment">//创建file对象</span><br>     <span class="hljs-keyword">if</span>(!file1.exists())<br>            file1.createNewFile();<span class="hljs-comment">//在磁盘创建该文件</span><br>     file.transferTo(file1);<span class="hljs-comment">//将接受的文件存储</span><br>     <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;sucucess&quot;</span>;<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>  @PostMapping(“onfile”) 的意思为该请求方式为post，且请求的url在项目中的相对地址为onfile</li><li>   @ResponseBody指不返回web页面，而是返回字符串或json字符串，在这里我们直接用一个成功单词代表跳转后的界面。    </li><li>   public String onfile(MultipartFile file) 函数名不重复就行，而MultipartFile file就是SpringMVC封装的一个处理文件的接口，其中参数名(这里是file)要和前端界面文件名相同(input type=”file”,name=”file”中的name)，通过这个接口你可以更容易的对文件进行各种操作，而本案例就是将上传的文件保存到本地F盘。</li></ol><p>至此，单文件上传就完成啦，单文件上传前端需要注意的就是form表单的method类型以及 enctype参数，而服务端也只需要用MultipartFile 接口就可以很容易的对文件进行接受。</p><h2 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript">@GetMapping(<span class="hljs-string">&quot;download/&#123;filename&#125;&quot;</span>)<br>public ResponseEntity&lt;byte[]&gt;download(@PathVariable <span class="hljs-built_in">String</span> filename) throws IOException &#123;<br>    <span class="hljs-comment">//下载文件的路径(这里绝对路径)</span><br>    <span class="hljs-built_in">String</span> filepath= <span class="hljs-string">&quot;F:/download/&quot;</span>+filename;<br>    File file =<span class="hljs-keyword">new</span> File(filepath);<br>    <span class="hljs-comment">//创建字节输入流，这里不实用Buffer类</span><br>    InputStream <span class="hljs-keyword">in</span> = <span class="hljs-keyword">new</span> FileInputStream(file);<br>    <span class="hljs-comment">//available:获取输入流所读取的文件的最大字节数</span><br>    byte[] body = <span class="hljs-keyword">new</span> byte[<span class="hljs-keyword">in</span>.available()];<br>    <span class="hljs-comment">//把字节读取到数组中</span><br>    <span class="hljs-keyword">in</span>.read(body);<br>    <span class="hljs-comment">//设置请求头</span><br>    MultiValueMap&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>&gt; headers = <span class="hljs-keyword">new</span> HttpHeaders();<br>    headers.add(<span class="hljs-string">&quot;Content-Disposition&quot;</span>, <span class="hljs-string">&quot;attchement;filename=&quot;</span> + file.getName());<br>    <span class="hljs-comment">//设置响应状态</span><br>    HttpStatus statusCode = HttpStatus.OK;<br>    <span class="hljs-keyword">in</span>.close();<br>    ResponseEntity&lt;byte[]&gt; entity = <span class="hljs-keyword">new</span> ResponseEntity&lt;byte[]&gt;(body, headers, statusCode);<br>    <span class="hljs-keyword">return</span> entity;<span class="hljs-comment">//返回</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这样就是实现了文件下载功能，如果用传统servlet的方式下载文件可能需要在HttpServletResponse response中设置各种信息，而使用SpringMVC的ResponseEntity只需要将文件二进制主体、头信息以及状态码设置好即可进行文件下载，在易用性和简洁上更胜一筹。</p></blockquote><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>此时你就遇到了一个文件下载非常常见的问题：中文文件名错误显示。这个解决方案也很容易解决，只需将Content-Disposition内容后面的文件名进行url编码即可，具体代码为(替换上面对于部分)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">headers.add(<span class="hljs-string">&quot;Content-Disposition&quot;</span>, <span class="hljs-string">&quot;attchement;filename=&quot;</span> + URLEncoder.encode(file.getName(), <span class="hljs-string">&quot;UTF-8&quot;</span>));<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>springboot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springboot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java io 之字节流</title>
    <link href="/2021/06/19/java%20io/"/>
    <url>/2021/06/19/java%20io/</url>
    
    <content type="html"><![CDATA[<p>这是关于java基础中的io流的学习博客<br><a href="https://baijiahao.baidu.com/s?id=1600984799323133994&wfr=spider&for=pc">参考博客</a><br><a href="https://github.com/dunwu/javacore/blob/master/docs/io/java-io.md">参考博客二</a></p><h2 id="传统IO流——BIO"><a href="#传统IO流——BIO" class="headerlink" title="传统IO流——BIO"></a>传统IO流——BIO</h2><p>BIO 中操作的流主要有两大类，字节流和字符流，两类根据流的方向都可以分为输入流和输出流。</p><ul><li><p>字节流</p><blockquote><p>输入字节流：InputStream<br>  输出字节流：OutputStream</p></blockquote></li><li><p>字符流</p><blockquote><p>输入字符流：Reader<br> 输出字符流：Writer</p></blockquote></li></ul><h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><p>字节流主要操作字节数据或二进制对象。</p><p>字节流有两个核心抽象类：InputStream 和 OutputStream。所有的字节流类都继承自这两个抽象类。</p><p><img src="./images/20200219133627.png" alt="enter description here"></p><h3 id="文件字节流"><a href="#文件字节流" class="headerlink" title="文件字节流"></a>文件字节流</h3><p>FileOutputStream 和 FileInputStream 提供了读写字节到文件的能力。</p><p>文件流操作一般步骤：</p><ol><li>使用 File 类绑定一个文件。</li><li>把 File 对象绑定到流对象上。</li><li>进行读或写操作。</li><li>关闭流</li></ol><h2 id="FileInputStream的api"><a href="#FileInputStream的api" class="headerlink" title="FileInputStream的api"></a>FileInputStream的api</h2><ul><li>构造方法<blockquote><p>//通过打开一个到实际文件的连接来创建一个 FileInputStream，该文件通过文件系统中的 File 对象 file 指定。<br>public FileInputStream(File file);<br>//通过打开一个到实际文件的连接来创建一个 FileInputStream，该文件通过文件系统中的路径名 name 指定。<br>public FileInputStream(String name);</p></blockquote></li></ul><h2 id="读取文件的三种方式"><a href="#读取文件的三种方式" class="headerlink" title="读取文件的三种方式"></a>读取文件的三种方式</h2><ul><li><p>从输入流中读取一个字节大小的数据</p><blockquote><p>//从此输入流中读取一个数据字节。<br>public int read();</p></blockquote></li><li><p>从输入流一次读取一个字节数组</p><blockquote><p>//从此输入流中将最多 b.length 个字节的数据读入一个 byte 数组中。<br>public int read(byte[] b);</p></blockquote></li></ul><ul><li>指定被读取文件的len长字节数据，偏移off个字节的长度，读入到字符数组中<blockquote><p>//从此输入流中将最多 len 个字节的数据读入一个 byte 数组中。off:目标数组 b 中的起始偏移量。<br>public int read(byte[] b,int off,int len);</p></blockquote></li></ul><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><blockquote><p>第一种方式</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 一般使用try catch捕获异常，并且在finally中关闭文件流</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">(String filePath)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;<br>        File file = <span class="hljs-keyword">new</span> File(filePath);<br>        InputStream inputStream = <span class="hljs-keyword">new</span> FileInputStream(file);<br>        <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[(<span class="hljs-keyword">int</span>) file.length()];<br>        inputStream.read(bytes);<br>        System.out.println(<span class="hljs-keyword">new</span> String(bytes));<br>    &#125;<br></code></pre></td></tr></table></figure><blockquote><p>第二种方式</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">(String filePath)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>       <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br>       File file = <span class="hljs-keyword">new</span> File(filePath);<br>       InputStream inputStream = <span class="hljs-keyword">new</span> FileInputStream(file);<br>       <span class="hljs-keyword">while</span> ((a=inputStream.read())!= -<span class="hljs-number">1</span>)&#123;<br>           System.out.print((<span class="hljs-keyword">char</span>) a);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><blockquote><p>第三种方式</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">(String filePath)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>          <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;<br>          File file = <span class="hljs-keyword">new</span> File(filePath);<br>          InputStream inputStream = <span class="hljs-keyword">new</span> FileInputStream(file);<br>          <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>          <span class="hljs-keyword">while</span> ((size=inputStream.read(buffer))!= -<span class="hljs-number">1</span>)&#123;<br>              String context = <span class="hljs-keyword">new</span> String(buffer, <span class="hljs-number">0</span>, size);<br>              System.out.println(context);<br>          &#125;<br></code></pre></td></tr></table></figure><h2 id="FileOutputStream的构造方法"><a href="#FileOutputStream的构造方法" class="headerlink" title="FileOutputStream的构造方法"></a>FileOutputStream的构造方法</h2><blockquote><p>//通过打开一个到实际文件的连接来创建一个 FileoutputStream，该文件通过文件系统中的 File 对象 file 指定。<br>public FileoutputStream(File file);<br>//通过打开一个到实际文件的连接来创建一个 FileoutputStream，该文件通过文件系统中的路径名 name 指定。<br>public FileoutputStream(String name);</p></blockquote><blockquote><p>public FileoutputStream(File file,boolean append);<br>public FileoutputStream(String name,boolean append);<br>append 为 True时，对文件内容进行追加操作</p></blockquote><h3 id="FileoutputStream写入文件方法"><a href="#FileoutputStream写入文件方法" class="headerlink" title="FileoutputStream写入文件方法"></a>FileoutputStream写入文件方法</h3><ul><li>使用write(int b)方法写入文件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(String filePath)</span> <span class="hljs-keyword">throws</span> IOException</span>&#123;<br>        FileOutputStream output = <span class="hljs-keyword">new</span> FileOutputStream(filePath,<span class="hljs-keyword">true</span>);<br>        String str = <span class="hljs-string">&quot;cccc&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str.length(); i++) &#123;<br>            <span class="hljs-keyword">int</span> s = (<span class="hljs-keyword">int</span>)str.charAt(i);<br>            output.write(s);<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>使用write(byte[] b)方法写入文件。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(String filePath)</span> <span class="hljs-keyword">throws</span> IOException</span>&#123;<br>        FileOutputStream output = <span class="hljs-keyword">new</span> FileOutputStream(filePath,<span class="hljs-keyword">true</span>);<br>        String str = <span class="hljs-string">&quot;cccc&quot;</span>;<br>        output.write(str.getBytes());<br><br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>使用write(byte[] b,int off,int len)方法写入文件。<blockquote><p>第一个参数为byte数组，第二个参数5是从byte数组的下标开始，第三个参数是写入的字节数</p></blockquote></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(String filePath)</span> <span class="hljs-keyword">throws</span> IOException</span>&#123;<br>       FileOutputStream output = <span class="hljs-keyword">new</span> FileOutputStream(filePath,<span class="hljs-keyword">true</span>);<br>       String str = <span class="hljs-string">&quot;ddddd&quot;</span>;<br>       output.write(str.getBytes(),<span class="hljs-number">0</span>,<span class="hljs-number">5</span>);<br><br>   &#125;<br></code></pre></td></tr></table></figure><p>demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileStreamDemo</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String FILEPATH = <span class="hljs-string">&quot;temp.log&quot;</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        write(FILEPATH);<br>        read(FILEPATH);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(String filepath)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">// 第1步、使用File类找到一个文件</span><br>        File f = <span class="hljs-keyword">new</span> File(filepath);<br><br>        <span class="hljs-comment">// 第2步、通过子类实例化父类对象</span><br>        OutputStream out = <span class="hljs-keyword">new</span> FileOutputStream(f);<br>        <span class="hljs-comment">// 实例化时，默认为覆盖原文件内容方式；如果添加true参数，则变为对原文件追加内容的方式。</span><br>        <span class="hljs-comment">// OutputStream out = new FileOutputStream(f, true);</span><br><br>        <span class="hljs-comment">// 第3步、进行写操作</span><br>        String str = <span class="hljs-string">&quot;Hello World\n&quot;</span>;<br>        <span class="hljs-keyword">byte</span>[] bytes = str.getBytes();<br>        out.write(bytes);<br><br>        <span class="hljs-comment">// 第4步、关闭输出流</span><br>        out.close();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">(String filepath)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">// 第1步、使用File类找到一个文件</span><br>        File f = <span class="hljs-keyword">new</span> File(filepath);<br><br>        <span class="hljs-comment">// 第2步、通过子类实例化父类对象</span><br>        InputStream input = <span class="hljs-keyword">new</span> FileInputStream(f);<br><br>        <span class="hljs-comment">// 第3步、进行读操作</span><br>        <span class="hljs-comment">// 有三种读取方式，体会其差异</span><br>        <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[(<span class="hljs-keyword">int</span>) f.length()];<br>        <span class="hljs-keyword">int</span> len = input.read(bytes); <span class="hljs-comment">// 读取内容</span><br>        System.out.println(<span class="hljs-string">&quot;读入数据的长度：&quot;</span> + len);<br><br>        <span class="hljs-comment">// 第4步、关闭输入流</span><br>        input.close();<br>        System.out.println(<span class="hljs-string">&quot;内容为：\n&quot;</span> + <span class="hljs-keyword">new</span> String(bytes));<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="文件复制demo"><a href="#文件复制demo" class="headerlink" title="文件复制demo"></a>文件复制demo</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">copy_demo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String dest = <span class="hljs-string">&quot;F:\\myblogssm\\demo_copy.txt&quot;</span>;<br>        String source = <span class="hljs-string">&quot;F:\\myblogssm\\demo.txt&quot;</span>;<br>        copyFile(dest,source);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">copyFile</span><span class="hljs-params">(String dest,String sour)</span></span>&#123;<br>        File fdest = <span class="hljs-keyword">new</span> File(dest);<br>        File fsour = <span class="hljs-keyword">new</span> File(sour);<br>        <span class="hljs-keyword">if</span> (!fsour.exists())&#123;<br>            System.out.println(<span class="hljs-string">&quot;源文件不存在&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            fdest.createNewFile();<br>            FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(fsour);<br>            FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(dest);<br>            <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[(<span class="hljs-keyword">int</span>) fsour.length()];<br>            fis.read(bytes);<br>            fos.write(bytes);<br>            fos.flush();<br><br>            fis.close();<br>            fos.close();<br>            System.out.println(<span class="hljs-string">&quot;复制成功&quot;</span>);<br><br><br><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="文件复制更简单demo"><a href="#文件复制更简单demo" class="headerlink" title="文件复制更简单demo"></a>文件复制更简单demo</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span>  </span>&#123;<br>       <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;<br>           FileReader fr = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;F:\\myblogssm\\target.txt&quot;</span>);<br>           FileWriter fw = <span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;F:\\myblogssm\\target_copy.txt&quot;</span>);<br>           <span class="hljs-keyword">char</span>[] chars = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">3</span>];<br>           <span class="hljs-keyword">while</span> ((length = fr.read(chars)) != -<span class="hljs-number">1</span>)&#123;<br>               fw.write(chars);<br>           &#125;<br><br>           fr.close();<br>           fw.close();<br><br><br>       &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>           e.printStackTrace();<br>       &#125;<br><br>   &#125;<br></code></pre></td></tr></table></figure><blockquote><p>source为源文件，dest为复制文件，其中不用关心dest是否存在，不存在会被创建，这个读取写入的过程，是每次读取三个字符到数组，并且一次写入文件，值得注意的是源文件有非3的整数倍的字符，会有意料不到的结果，如 源文件中存储的是    欢迎学习文件存取知识   ，复制到另一文件结果是  欢迎学习文件存取知识取知。这是因为最后一次字符数组存储的是’识‘，而上次存储的’存取知‘只是被顶掉了一个，所以最后存储的是’识取知‘</p></blockquote><blockquote><p>解决办法<br>每次写入是，需要限定写入数组长度，即限定写入每次读取到的长度</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span>  </span>&#123;<br>       <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;<br>           FileReader fr = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;F:\\myblogssm\\target.txt&quot;</span>);<br>           FileWriter fw = <span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;F:\\myblogssm\\target_copy.txt&quot;</span>);<br>           <span class="hljs-keyword">char</span>[] chars = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">3</span>];<br>           <span class="hljs-keyword">while</span> ((length = fr.read(chars)) != -<span class="hljs-number">1</span>)&#123;<br>               System.out.println(length);<br>               fw.write(chars,<span class="hljs-number">0</span>,length);<br>           &#125;<br><br>           fr.close();<br>           fw.close();<br><br><br>       &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>           e.printStackTrace();<br>       &#125;<br><br>   &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java io</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java io之 字符流</title>
    <link href="/2021/06/19/java%20io%E4%B9%8B%20%E5%AD%97%E7%AC%A6%E6%B5%81/"/>
    <url>/2021/06/19/java%20io%E4%B9%8B%20%E5%AD%97%E7%AC%A6%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<p>这是关于java基础中的io流的学习博客<br><a href="https://mp.weixin.qq.com/s/AtYw_IufJnBjJDM-F6YIAA">参考博客</a><br><a href="https://github.com/dunwu/javacore/blob/master/docs/io/java-io.md">参考博客二</a></p><h2 id="java读写文件的分类"><a href="#java读写文件的分类" class="headerlink" title="java读写文件的分类"></a>java读写文件的分类</h2><p><img src="./images/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20210619170412.png" alt="enter description here"></p><h2 id="字节流与字符流差异"><a href="#字节流与字符流差异" class="headerlink" title="字节流与字符流差异"></a>字节流与字符流差异</h2><blockquote><p>中文和英文在字符编码上存在一定性的差异，因为最开始使用的 ASCII编码表 的 256 个字符并没有支持中文，中文编码系统大多数采用的是 GBK 和 UTF-8 。</p></blockquote><blockquote><p>在 GBK 编码表中，一个中文字符占用两个字节，UTF-8 中占用了 3 个字节，如果我们采用字节读写的方式读写中文字符就会出现中文编程乱码的情况， 我们都知道 Java 这么风靡很大部分还是因为他的跨平台性，但如果连语言都没有搞定那还怎么牛逼起来，所以 java 为了避免这种情况引进了字符的读写操作。</p></blockquote><h2 id="字符输出流操作"><a href="#字符输出流操作" class="headerlink" title="字符输出流操作"></a>字符输出流操作</h2><blockquote><p>Writer 是一个用于写入字符流的 「抽象类」。子类必须实现的方法仅有 write(char[], int, int)、flush() 和 close()。它是所有字符输出流的父类</p></blockquote><h3 id="wirter常用方法"><a href="#wirter常用方法" class="headerlink" title="wirter常用方法"></a>wirter常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//写入一个字符</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">//写入一个字符数组</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] cbuf)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">//写入字符串</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(String str)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">//写入字符数组的一部分,从off索引开始,写入len个字符</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] cbuf, <span class="hljs-keyword">int</span> off, <span class="hljs-keyword">int</span> len)</span></span><br></code></pre></td></tr></table></figure><p>wirter是抽象类，无法直接使用，所以我们使用它的直接子类FileWriter </p><h3 id="FileWriter-的构造方法"><a href="#FileWriter-的构造方法" class="headerlink" title="FileWriter 的构造方法"></a>FileWriter 的构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*覆盖形式写入，即从文件的开头进行写入*/</span><br><br><span class="hljs-comment">//根据给定的 File 对象构造一个 FileWriter 对象。</span><br>FileWriter(File file)   <br><br><span class="hljs-comment">//根据给定的文件名构造一个 FileWriter 对象。</span><br>FileWriter(String filename)   <br><br><span class="hljs-comment">/*追加形式的写入</span><br><span class="hljs-comment">  若传入的append参数是true则进行追加形式的写入，</span><br><span class="hljs-comment">  即从文件末尾写入*/</span><br>FileWriter(File file, <span class="hljs-keyword">boolean</span> append)<br>FileWriter(String filename, <span class="hljs-keyword">boolean</span> append)<br><br><br><br></code></pre></td></tr></table></figure><p>它跟字符输入流的区别就是他会对磁盘文件进行操作，所以使用字符输出流的时候要注意有两个必须运行的方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//刷新该缓冲流，即 ，将使用的Wrtier流写入到本地文件中，而不是存于内存中</span><br><span class="hljs-keyword">void</span> flush()   <br><br><span class="hljs-comment">//关闭流，并且释放资源，但必须先刷新流         </span><br><span class="hljs-keyword">void</span> close()      <br></code></pre></td></tr></table></figure><h2 id="通过代码来学习字符输出流"><a href="#通过代码来学习字符输出流" class="headerlink" title="通过代码来学习字符输出流"></a>通过代码来学习字符输出流</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript">public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>       <span class="hljs-built_in">String</span> FilePath = <span class="hljs-string">&quot;F:\\myblogssm\\FileWriter_demo.txt&quot;</span>;<br>       <span class="hljs-keyword">try</span> &#123;<br>           FileWriter fw = <span class="hljs-keyword">new</span> FileWriter(FilePath);<br>           fw.write(<span class="hljs-number">100</span>);<br>           fw.flush();<br><br>           char[] cbuf = &#123;<span class="hljs-string">&#x27;h&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>&#125;;<br>           fw.write(cbuf);<br>fw.flush();<br><br>           fw.write(<span class="hljs-string">&quot;学习FileWriter&quot;</span>);<br>           fw.flush();<br><br>           fw.write(<span class="hljs-string">&quot;你好，世界&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>);<br>           fw.flush();<br>           <br>           fw.close();<br><br>       &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>           e.printStackTrace();<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="字符输入流Reader"><a href="#字符输入流Reader" class="headerlink" title="字符输入流Reader"></a>字符输入流Reader</h2><blockquote><p>「Reader」是一个用于读取字符流的「抽象类」。子类必须实现的方法只有 read(char[], int, int) 和 close()。<br>它是所有字符输入流的父类。<br>以下是 Reader 类中常用的几个方法:</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*返回值用于存放读取结果，如果到达文件末尾，则返回-1*/</span><br><br><span class="hljs-comment">//读取单个字符。</span><br>int read()<br><br><span class="hljs-comment">//将字符读入数组。 </span><br>int read(char[] cbuf)<br><br><span class="hljs-comment">//将字符读入数组的某一部分。 </span><br>int read(char[] cbuf, int off, int len)<br></code></pre></td></tr></table></figure><p>同样的，由于Reader是一个抽象类,我们并不能直接的使用他,所以要找出Reader的子类。</p><p>在java中有一个Reader的直接子类 FileReader, 它的的 read 方法都继承自 Reader ；所以我们不必再去研究 FileReader 中的方法, 只需要把重心放到 FileReader 的构造方法中。</p><ul><li>FileReader 的构造方法<blockquote><p>//在给定从中读取数据的 File 的情况下创建一个新 FileReader。<br>FileReader(File file)<br>//在给定从中读取数据的文件名的情况下创建一个新 FileReader。<br>FileReader(String fileName)</p></blockquote></li></ul><h2 id="读取文件的demo"><a href="#读取文件的demo" class="headerlink" title="读取文件的demo"></a>读取文件的demo</h2><blockquote><p>第一种方式</p></blockquote><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">try</span> &#123;<br>            FileReader fr = <span class="hljs-keyword">new</span> <span class="hljs-constructor">FileReader(<span class="hljs-string">&quot;F:\\myblogssm\\FileWriter_demo.txt&quot;</span>)</span>;<br>            <span class="hljs-built_in">int</span> len = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> ((len=fr.read<span class="hljs-literal">()</span>)!= -<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.print((<span class="hljs-built_in">char</span>) len);<br>            &#125;<br><br>        &#125; catch (IOException e) &#123;<br>            e.print<span class="hljs-constructor">StackTrace()</span>;<br>        &#125;<br></code></pre></td></tr></table></figure><blockquote><p>第二种方式</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">try</span> &#123;<br>           FileReader fr = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;F:\\myblogssm\\FileWriter_demo.txt&quot;</span>);<br>           char[] cbuf = <span class="hljs-keyword">new</span> char[<span class="hljs-number">1024</span>];<br>           fr.read(cbuf);<br>           <span class="hljs-keyword">for</span> (char c : cbuf) &#123;<br>               System.out.print(c);<br>           &#125;<br><br>       &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>           e.printStackTrace();<br>       &#125;<br></code></pre></td></tr></table></figure><p>总结：字节流写入读取文件使用的缓存区是字节数组，字符流的缓冲区是字符数组<br>字节每次操作的单位是一个字节，字符流每次操作的单位是字符</p>]]></content>
    
    
    <categories>
      
      <category>javaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaWeb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模板引擎</title>
    <link href="/2021/06/19/freemarker/"/>
    <url>/2021/06/19/freemarker/</url>
    
    <content type="html"><![CDATA[<p>这是关于springboot支持的模板引擎freemarker的学习博客<br><a href="http://freemarker.foofun.cn/toc.html">中文文档</a></p><h2 id="官网对freemarker的介绍"><a href="#官网对freemarker的介绍" class="headerlink" title="官网对freemarker的介绍"></a>官网对freemarker的介绍</h2><blockquote><p> 模板 + 引擎 = 输出<br>    <img src="./images/1624029813827.png" alt="enter description here"></p></blockquote><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>实际上用程序语言编写的程序就是模板。 FTL (代表FreeMarker模板语言)。 这是为编写模板设计的非常简单的编程语言。</p><p>模板(FTL编程)是由如下部分混合而成的：</p><ul><li>文本：文本会照着原样来输出。</li><li>插值：这部分的输出会被计算的值来替换。插值由 ${ and } 所分隔(或者 #{ and }，这种风格已经不建议再使用了；</li><li>FTL 标签：FTL标签和HTML标签很相似，但是它们却是给FreeMarker的指示， 而且不会打印在输出内容中。</li><li>注释：注释和HTML的注释也很相似，但它们是由 &lt;#– 和 –&gt;来分隔的。注释会被FreeMarker直接忽略， 更不会在输出内容中显示。</li></ul><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;html&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Welcome!<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="xml">  &lt;#-- Greet the user with his/her name --&gt;</span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Welcome $&#123;user&#125;!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>We have these animals:</span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">  &lt;#list animals as animal&gt;</span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>$&#123;animal.name&#125; for $&#123;animal.price&#125; Euros</span><br><span class="xml">  &lt;/#list&gt;</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></code></pre></td></tr></table></figure><blockquote><p>FTL是区分大小写的。 list 是指令的名称而 List 就不是。类似地 ${name} 和 ${Name} 或 ${NAME} 也是不同的。请注意非常重要的一点： 插值 仅仅可以在 文本 中使用。 (也可以是字符串表达式；请参考 后续内容)FTL 标签 不可以在其他 FTL 标签 和 插值中使用。比如， 这样做是 错误 的： &lt;#if &lt;#include ‘foo’&gt;=’bar’&gt;…&lt;/#if&gt;注释 可以放在 FTL 标签 和 插值中。</p></blockquote><h2 id="模板引擎-结合springboot"><a href="#模板引擎-结合springboot" class="headerlink" title="模板引擎(结合springboot)"></a>模板引擎(结合springboot)</h2><h3 id="在springboot中集成freemarker"><a href="#在springboot中集成freemarker" class="headerlink" title="在springboot中集成freemarker"></a>在springboot中集成freemarker</h3><ul><li>所需要的maven依赖</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><ul><li>配置信息</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript">## Freemarker 配置<br>##模版存放路径（默认为 classpath:<span class="hljs-regexp">/templates/</span>）<br>spring.freemarker.template-loader-path=classpath:<span class="hljs-regexp">/templates/</span><br>##是否生成缓存，生成环境建议开启（默认为<span class="hljs-literal">true</span>）<br>spring.freemarker.cache=<span class="hljs-literal">false</span><br>##编码<br>spring.freemarker.charset=UTF-<span class="hljs-number">8</span><br>spring.freemarker.check-template-location=<span class="hljs-literal">true</span><br>##content-type类型(默认为test/html)<br>spring.freemarker.content-type=text/html<br>## 设定所有request的属性在merge到模板的时候，是否要都添加到model中（默认为<span class="hljs-literal">false</span>）<br>spring.freemarker.expose-request-attributes=<span class="hljs-literal">false</span><br>##设定所有HttpSession的属性在merge到模板的时候，是否要都添加到model中.(默认为<span class="hljs-literal">false</span>)<br>spring.freemarker.expose-session-attributes=<span class="hljs-literal">false</span><br>##RequestContext属性的名称（默认为-）<br>spring.freemarker.request-context-attribute=request<br>##模板后缀(默认为.ftl)<br>spring.freemarker.suffix=.html<br><br></code></pre></td></tr></table></figure><ul><li>先modelAndView中写入输入，flt模板文件一般存在template/freemarker中</li></ul><blockquote><p>方法一   使用ModelMap</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/index&quot;)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">index</span><span class="hljs-params">(ModelMap modelMap)</span></span>&#123;<br>       Map map = db.dbSources();<br>       modelMap.put(<span class="hljs-string">&quot;map&quot;</span>,map);<br>       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;freemarker/index&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>方法二  使用ModelAndView，注意的是不能在接受参数时，直接传入modelAndView，没有绑定到模板，会产生错误</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapp</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">index</span><span class="hljs-params">(HttpServletRequest request)</span></span>&#123;<br>        ModelAndView modelAndView = <span class="hljs-keyword">new</span> ModelAndView(<span class="hljs-string">&quot;/freemarker/index&quot;</span>);<br>        Map map = db.dbSources();<br>        modelAndView.addObject(<span class="hljs-string">&quot;map&quot;</span>,map);<br>        <span class="hljs-keyword">return</span> modelAndView;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>方法三 使用model</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/index&quot;)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">index</span><span class="hljs-params">(Model model)</span></span>&#123;<br>       Map map = db.dbSources();<br>       model.addAttribute(<span class="hljs-string">&quot;map&quot;</span>,map);<br>       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;freemarker/index&quot;</span>;<br><br></code></pre></td></tr></table></figure><blockquote><p>总结，使用model和modelMap都可以，直接加入数据，然后重定向到页面，使用modelandview不行，必须进行绑定</p></blockquote><h3 id="数据的读取"><a href="#数据的读取" class="headerlink" title="数据的读取"></a>数据的读取</h3><h5 id="读取数据的方式"><a href="#读取数据的方式" class="headerlink" title="读取数据的方式"></a>读取数据的方式</h5><ul><li>指令</li><li>表达式</li><li>差值<br><a href="http://freemarker.foofun.cn/dgui_template.html">详细命令见官方文档</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>javaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaWeb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cookie</title>
    <link href="/2021/06/18/cookie/"/>
    <url>/2021/06/18/cookie/</url>
    
    <content type="html"><![CDATA[<p>这是关于javaWeb中cookie的学习博客，记录一些cookie的常见用法和细节</p><h2 id="javaWeb重定向"><a href="#javaWeb重定向" class="headerlink" title="javaWeb重定向"></a>javaWeb重定向</h2><blockquote><p>1、response.sendRedirect(“”)<br>2、</p></blockquote><h2 id="cookie的细节"><a href="#cookie的细节" class="headerlink" title="cookie的细节"></a>cookie的细节</h2><blockquote><p>1、cookie保存的是键值对<br>2、一个web站点可以给浏览器发送多个cookie，浏览器也可以存储多个cookie<br>3、浏览器一般只能存放300个cookie，每个cookie的大小限制为4KB<br>4、创建了cookie，并发送到浏览器，默认是会话级别的（存储在内存中），<br> 设置过期时间会让cookie存储在本地,将过期时间设为0；则是要删除cookie，设置时间的api是setMaxAge.<br>5、删除cookie时，路径要相同，否则不会被删除。</p></blockquote><h2 id="cookie常用api"><a href="#cookie常用api" class="headerlink" title="cookie常用api"></a>cookie常用api</h2><blockquote><p>1.setMaxAge  设置session有效期，正值为以秒计算过时失效,负值为关闭客户端失效,默认值为-1。<br>2、setDomain  用于指定只有请求了指定的域名，才会带上该cookie<br>3、setPath  只有访问该域名下的cookieDemo的这个路径地址才会带cookie<br>4、setValue  重置value的值</p></blockquote><h3 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript">protected <span class="hljs-keyword">void</span> doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;<br><span class="hljs-comment">//获取客户段发过来的cookie</span><br>Cookie[] cookies = request.getCookies();<br><span class="hljs-keyword">if</span>(cookies!=<span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">for</span> (Cookie c : cookies) &#123;<br>System.out.println(c.getName()+<span class="hljs-string">&quot;=&quot;</span>+c.getValue());<br>&#125;<br>&#125;<br><br>response.getWriter().write(<span class="hljs-string">&quot;Hello cookie..&quot;</span>);<br><br><span class="hljs-comment">//添加多个cookie</span><br>Cookie cookie = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;刘备&quot;</span>);<br><span class="hljs-comment">//cookie的有效期</span><br><span class="hljs-comment">//正值为以秒计算过时失效,负值为关闭客户端失效,默认值为-1</span><br>cookie.setMaxAge(<span class="hljs-number">60</span>*<span class="hljs-number">60</span>*<span class="hljs-number">24</span>*<span class="hljs-number">3</span>);  <span class="hljs-comment">//设置有效期为3天</span><br>response.addCookie(cookie);<br>Cookie cookie2 = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">&quot;age&quot;</span>,<span class="hljs-string">&quot;63&quot;</span>);<br>response.addCookie(cookie2);<br><br><span class="hljs-comment">//用于指定只有请求了指定的域名，才会带上该cookie</span><br>cookie.setDomain(<span class="hljs-string">&quot;.huaban.com&quot;</span>);<br><br><span class="hljs-comment">//只有访问该域名下的cookieDemo的这个路径地址才会带cookie</span><br>cookie.setPath(<span class="hljs-string">&quot;/CookieDemo&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="结合springboot返回cookie"><a href="#结合springboot返回cookie" class="headerlink" title="结合springboot返回cookie"></a>结合springboot返回cookie</h3>]]></content>
    
    
    <categories>
      
      <category>javaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaWeb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>建立自己的博客</title>
    <link href="/2021/06/17/%E4%BD%BF%E7%94%A8hexo%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%88%B0github%20page%E4%B8%8A/"/>
    <url>/2021/06/17/%E4%BD%BF%E7%94%A8hexo%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%88%B0github%20page%E4%B8%8A/</url>
    
    <content type="html"><![CDATA[<p>总体来说，不是很难</p><p>*第一步，创建github仓库，注意名字一定要是  github用户名.github.io  (大坑，浪费我很多时间)</p><blockquote><p>使用hexo init 本地初始化时，可能会因为git 通过https克隆仓库失败，导致初始化不了，直接使用ssl克隆快速开始项目</p></blockquote><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog">hexo init  <span class="hljs-comment">//初始化项目</span><br>hexo <span class="hljs-keyword">generate</span>   <span class="hljs-comment">//生成public静态文件</span><br>hexo server   <span class="hljs-comment">//运行，可在localhost:4040访问</span><br></code></pre></td></tr></table></figure><blockquote><p>先本地运行起hexo博客，即达到本地访问无问题，主要修改主题比较麻烦，在theme中放一个主题，修改_config.yml中的theme的指向，完成主题的更改<br>本地访问没有问题后使用如下指令部署到github服务器上</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">hexo clean<br>hexo deploy  <span class="hljs-regexp">//</span>会将本地的public文件夹覆盖到仓库里面<br></code></pre></td></tr></table></figure><blockquote><p>值得说的是仓库名起错了，就太折腾了  <a href="https://blog.csdn.net/weixin_29092579/article/details/112100678">配置域名博客</a><br><a href="https://hexo.io/zh-cn/docs/">hexo中文网</a></p><p>如上教程绑定域名，在此提交文件后，会被取消掉，在source文件夹下创建CNAME文件，里面写入顶层域名（即服务器给你提供的那个），才不会被刷新掉</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/06/16/hello-world/"/>
    <url>/2021/06/16/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
